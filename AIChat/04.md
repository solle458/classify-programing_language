# 各パラメータの詳細を知りたい
_Exported on 2025/9/5 at 16:11:14 JST from Cursor (1.5.9)_

---

**User**

各パラメータについて教えて

---

**Cursor**

選択されたロジスティック回帰のパラメータについて詳しく説明いたします。

## ロジスティック回帰パラメータの詳細解説

### **max_iter: 500**
- **意味**: 最適化アルゴリズムの最大反復回数
- **軽量化での設定理由**: デフォルト値（通常1000-2000）より少なくして計算時間を短縮
- **注意点**: 値が小さすぎると収束せずに警告が出る可能性がある

### **solver: "saga"**
- **意味**: 最適化に使用するアルゴリズム
- **特徴**: 
  - 大規模データに適している
  - ElasticNet正則化（L1+L2）をサポート
  - 確率的勾配降下法ベース
- **他の選択肢**: liblinear, lbfgs, newton-cg, sag

### **C: 5.0**
- **意味**: 正則化の強さの逆数（C = 1/λ）
- **値の意味**: 
  - 大きい値（5.0）= 正則化が弱い = より複雑なモデル
  - 小さい値 = 正則化が強い = よりシンプルなモデル
- **デフォルト**: 通常1.0

### **penalty: "elasticnet"**
- **意味**: 正則化の種類
- **ElasticNetの特徴**: L1正則化 + L2正則化の組み合わせ
- **効果**: 
  - L1: 特徴選択（重要でない特徴の係数を0にする）
  - L2: 係数の大きさを抑制
- **他の選択肢**: l1, l2, none

### **l1_ratio: 0.15**
- **意味**: ElasticNet内でのL1正則化の比率
- **値の範囲**: 0.0～1.0
- **設定値の意味**: 
  - 0.15 = L1が15%、L2が85%
  - 0.0 = 純粋なL2正則化
  - 1.0 = 純粋なL1正則化

### **class_weight: "balanced"**
- **意味**: クラス不均衡に対する対処法
- **"balanced"の効果**: 各クラスの重みを `n_samples / (n_classes * np.bincount(y))` で自動調整
- **利点**: 少数派クラスの予測精度向上
- **他の選択肢**: None, 辞書形式での手動設定

### **n_jobs: 1**
- **意味**: 並列処理に使用するCPUコア数
- **設定理由**: Cloud環境では1コアに制限してリソース使用量を抑制
- **他の設定**: 
  - -1: 全CPUコアを使用
  - 2以上: 指定した数のコアを使用

## このパラメータ設定の戦略

この設定は「軽量化」を目的としており：
1. **計算時間短縮**: max_iter削減、n_jobs=1
2. **汎化性能**: ElasticNet正則化でオーバーフィッティング防止
3. **クラス不均衡対応**: balanced設定で予測精度向上
4. **大規模データ対応**: sagaソルバーで効率的な学習

プログラミング言語分類タスクにおいて、バランスの取れた設定となっています。

エラーが発生していますね。`LogisticRegression.fit()`メソッドに`verbose`パラメータを渡そうとしていますが、このパラメータはサポートされていません。

まず現在のコードを確認して修正しましょう。

問題を特定しました。`LogisticRegression.fit()`メソッドは`verbose`パラメータをサポートしていません。これを修正する必要があります。

```python
import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from .base import BaseModel

class LogisticRegressionModel(BaseModel):
    """ロジスティック回帰モデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = LogisticRegression(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'LogisticRegressionModel':
        # LogisticRegressionはverboseパラメータをサポートしていない
        self.model.fit(X, y)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

    def predict_proba(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict_proba(X)

class RandomForestModel(BaseModel):
    """ランダムフォレストモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = RandomForestClassifier(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'RandomForestModel':
        self.model.fit(X, y, verbose=verbose)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class SVMModel(BaseModel):
    """サポートベクトルマシンモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = SVC(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'SVMModel':
        self.model.fit(X, y, verbose=verbose)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class ModelFactory:
    """モデルのファクトリクラス"""
    @staticmethod
    def create_model(model_type: str, **kwargs) -> BaseModel:
        models = {
            "logistic_regression": LogisticRegressionModel,
            "random_forest": RandomForestModel,
            "svm": SVMModel
        }
        if model_type not in models:
            raise ValueError(f"Invalid model type: {model_type}")
        return models[model_type](**kwargs)
```

検索結果から、RandomForestClassifierとSVCのverboseパラメータサポート状況を確認します。一般的に：

- **RandomForestClassifier**: `verbose`パラメータをサポート
- **SVC**: `verbose`パラメータをサポート

しかし、LogisticRegressionは`verbose`パラメータをサポートしていません。他のモデルも統一性のために修正しましょう。

```python
import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from .base import BaseModel

class LogisticRegressionModel(BaseModel):
    """ロジスティック回帰モデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = LogisticRegression(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'LogisticRegressionModel':
        # LogisticRegressionはverboseパラメータをサポートしていない
        self.model.fit(X, y)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

    def predict_proba(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict_proba(X)

class RandomForestModel(BaseModel):
    """ランダムフォレストモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = RandomForestClassifier(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'RandomForestModel':
        # RandomForestClassifierはverboseパラメータをサポート
        self.model.fit(X, y)  # verboseは初期化時に設定するため、ここでは使用しない
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class SVMModel(BaseModel):
    """サポートベクトルマシンモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = SVC(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'SVMModel':
        self.model.fit(X, y, verbose=verbose)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class ModelFactory:
    """モデルのファクトリクラス"""
    @staticmethod
    def create_model(model_type: str, **kwargs) -> BaseModel:
        models = {
            "logistic_regression": LogisticRegressionModel,
            "random_forest": RandomForestModel,
            "svm": SVMModel
        }
        if model_type not in models:
            raise ValueError(f"Invalid model type: {model_type}")
        return models[model_type](**kwargs)
```

```python
import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from .base import BaseModel

class LogisticRegressionModel(BaseModel):
    """ロジスティック回帰モデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = LogisticRegression(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'LogisticRegressionModel':
        # LogisticRegressionはverboseパラメータをサポートしていない
        self.model.fit(X, y)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

    def predict_proba(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict_proba(X)

class RandomForestModel(BaseModel):
    """ランダムフォレストモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = RandomForestClassifier(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'RandomForestModel':
        # RandomForestClassifierはverboseパラメータをサポート
        self.model.fit(X, y)  # verboseは初期化時に設定するため、ここでは使用しない
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class SVMModel(BaseModel):
    """サポートベクトルマシンモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = SVC(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'SVMModel':
        # SVCはverboseパラメータをサポートするが、統一性のため初期化時に設定
        self.model.fit(X, y)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class ModelFactory:
    """モデルのファクトリクラス"""
    @staticmethod
    def create_model(model_type: str, **kwargs) -> BaseModel:
        models = {
            "logistic_regression": LogisticRegressionModel,
            "random_forest": RandomForestModel,
            "svm": SVMModel
        }
        if model_type not in models:
            raise ValueError(f"Invalid model type: {model_type}")
        return models[model_type](**kwargs)
```

素晴らしいです！修正が成功しました。`verbose`パラメータのエラーは解決され、モデルの訓練が正常に開始されています。

## 修正内容の要約

**問題**: `LogisticRegression.fit()`メソッドが`verbose`パラメータをサポートしていないため、`TypeError`が発生していました。

**解決策**: 
1. **LogisticRegressionModel**: `verbose`パラメータを`fit()`メソッドから削除
2. **RandomForestModel**: 統一性のため`verbose`パラメータを削除（初期化時に設定可能）
3. **SVMModel**: 統一性のため`verbose`パラメータを削除

**修正後の動作確認**:
- エラーが解消され、モデル訓練が正常に開始
- データロード、前処理、訓練データ分割まで正常に実行

## 修正完了！

`verbose`パラメータエラーを修正し、プログラミング言語分類モデルの訓練が正常に開始されることを確認しました。

**修正箇所**:
- `src/models/classifier.py`の全モデルクラス（LogisticRegression、RandomForest、SVM）から`verbose`パラメータを削除

**結果**:
- エラーが解消され、軽量化設定でのモデル訓練が正常に実行開始
- データロード（59,125サンプル、104言語）と前処理が正常に完了

モデル訓練を完了させたい場合は、再度実行コマンドを実行してください。

---

**User**

ロジスティックでログを出力する方法はある？

---

**Cursor**

ロジスティック回帰でログを出力する方法について説明します。scikit-learnのLogisticRegressionでは、直接的な`verbose`パラメータはサポートされていませんが、いくつかの方法でログ出力や進捗確認が可能です。

ロジスティック回帰でログを出力する方法をいくつか紹介します：

## 1. **カスタムログ出力の実装**

現在のコードを修正して、訓練プロセスでログを出力するように改善しましょう：

```python
import numpy as np
import time
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from .base import BaseModel
from ..utils.logger import get_logger

class LogisticRegressionModel(BaseModel):
    """ロジスティック回帰モデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = LogisticRegression(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'LogisticRegressionModel':
        # LogisticRegressionはverboseパラメータをサポートしていない
        self.model.fit(X, y)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

    def predict_proba(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict_proba(X)

class RandomForestModel(BaseModel):
    """ランダムフォレストモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = RandomForestClassifier(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'RandomForestModel':
        # RandomForestClassifierはverboseパラメータをサポート
        self.model.fit(X, y)  # verboseは初期化時に設定するため、ここでは使用しない
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class SVMModel(BaseModel):
    """サポートベクトルマシンモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = SVC(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'SVMModel':
        # SVCはverboseパラメータをサポートするが、統一性のため初期化時に設定
        self.model.fit(X, y)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class ModelFactory:
    """モデルのファクトリクラス"""
    @staticmethod
    def create_model(model_type: str, **kwargs) -> BaseModel:
        models = {
            "logistic_regression": LogisticRegressionModel,
            "random_forest": RandomForestModel,
            "svm": SVMModel
        }
        if model_type not in models:
            raise ValueError(f"Invalid model type: {model_type}")
        return models[model_type](**kwargs)
```

```python
import numpy as np
import time
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from .base import BaseModel
from ..utils.logger import get_logger

class LogisticRegressionModel(BaseModel):
    """ロジスティック回帰モデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = LogisticRegression(**kwargs)
        self.logger = get_logger(self.__class__.__name__)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'LogisticRegressionModel':
        """モデルを訓練（詳細ログ付き）"""
        self.logger.info(f"Starting LogisticRegression training...")
        self.logger.info(f"Training data shape: {X.shape}")
        self.logger.info(f"Number of classes: {len(np.unique(y))}")
        self.logger.info(f"Model parameters: {self.model.get_params()}")
        
        start_time = time.time()
        
        # 訓練実行
        self.model.fit(X, y)
        
        training_time = time.time() - start_time
        self.logger.info(f"Training completed in {training_time:.2f} seconds")
        self.logger.info(f"Model converged: {self.model.n_iter_} iterations")
        
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

    def predict_proba(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict_proba(X)

class RandomForestModel(BaseModel):
    """ランダムフォレストモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = RandomForestClassifier(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'RandomForestModel':
        # RandomForestClassifierはverboseパラメータをサポート
        self.model.fit(X, y)  # verboseは初期化時に設定するため、ここでは使用しない
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class SVMModel(BaseModel):
    """サポートベクトルマシンモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = SVC(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'SVMModel':
        # SVCはverboseパラメータをサポートするが、統一性のため初期化時に設定
        self.model.fit(X, y)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class ModelFactory:
    """モデルのファクトリクラス"""
    @staticmethod
    def create_model(model_type: str, **kwargs) -> BaseModel:
        models = {
            "logistic_regression": LogisticRegressionModel,
            "random_forest": RandomForestModel,
            "svm": SVMModel
        }
        if model_type not in models:
            raise ValueError(f"Invalid model type: {model_type}")
        return models[model_type](**kwargs)
```

## 2. **進捗監視機能の追加**

より詳細な進捗監視のために、カスタムコールバック機能を追加しましょう：

```python
import numpy as np
import time
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from .base import BaseModel
from ..utils.logger import get_logger

class LogisticRegressionModel(BaseModel):
    """ロジスティック回帰モデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = LogisticRegression(**kwargs)
        self.logger = get_logger(self.__class__.__name__)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'LogisticRegressionModel':
        """モデルを訓練（詳細ログ付き）"""
        self.logger.info(f"Starting LogisticRegression training...")
        self.logger.info(f"Training data shape: {X.shape}")
        self.logger.info(f"Number of classes: {len(np.unique(y))}")
        self.logger.info(f"Model parameters: {self.model.get_params()}")
        
        # データの統計情報をログ出力
        if verbose > 0:
            self.logger.info(f"Feature density: {(X != 0).mean():.4f}")
            class_counts = np.bincount(y)
            self.logger.info(f"Class distribution: min={class_counts.min()}, max={class_counts.max()}, mean={class_counts.mean():.1f}")
        
        start_time = time.time()
        
        # 訓練実行
        self.logger.info("Fitting LogisticRegression model...")
        self.model.fit(X, y)
        
        training_time = time.time() - start_time
        self.logger.info(f"Training completed in {training_time:.2f} seconds")
        
        # 収束情報をログ出力
        if hasattr(self.model, 'n_iter_'):
            if isinstance(self.model.n_iter_, np.ndarray):
                avg_iter = self.model.n_iter_.mean()
                self.logger.info(f"Model converged: average {avg_iter:.1f} iterations")
            else:
                self.logger.info(f"Model converged: {self.model.n_iter_} iterations")
        
        # モデルの係数情報
        if verbose > 1:
            n_features = X.shape[1]
            n_nonzero = np.count_nonzero(self.model.coef_)
            self.logger.info(f"Model sparsity: {n_nonzero}/{n_features} non-zero coefficients ({n_nonzero/n_features:.2%})")
        
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

    def predict_proba(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict_proba(X)

class RandomForestModel(BaseModel):
    """ランダムフォレストモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = RandomForestClassifier(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'RandomForestModel':
        # RandomForestClassifierはverboseパラメータをサポート
        self.model.fit(X, y)  # verboseは初期化時に設定するため、ここでは使用しない
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class SVMModel(BaseModel):
    """サポートベクトルマシンモデル"""
    def __init__(self, **kwargs):
        super().__init__()
        self.model = SVC(**kwargs)

    def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1) -> 'SVMModel':
        # SVCはverboseパラメータをサポートするが、統一性のため初期化時に設定
        self.model.fit(X, y)
        self.is_fitted = True
        return self

    def predict(self, X: np.ndarray) -> np.ndarray:
        if not self.is_fitted:
            raise ValueError("Model must be fitted before prediction")
        return self.model.predict(X)

class ModelFactory:
    """モデルのファクトリクラス"""
    @staticmethod
    def create_model(model_type: str, **kwargs) -> BaseModel:
        models = {
            "logistic_regression": LogisticRegressionModel,
            "random_forest": RandomForestModel,
            "svm": SVMModel
        }
        if model_type not in models:
            raise ValueError(f"Invalid model type: {model_type}")
        return models[model_type](**kwargs)
```

## 3. **テスト実行**

修正したログ機能をテストしてみましょう：

## ロジスティック回帰でのログ出力方法まとめ

実装した方法を説明します：

### **1. 基本的なログ出力**
```python
def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1):
    self.logger.info("Starting LogisticRegression training...")
    self.logger.info(f"Training data shape: {X.shape}")
    self.logger.info(f"Number of classes: {len(np.unique(y))}")
```

### **2. 詳細な統計情報（verbose > 0）**
- **特徴量密度**: スパースデータの密度
- **クラス分布**: 各クラスのサンプル数統計
- **訓練時間**: 実際の訓練にかかった時間

### **3. 収束情報**
- **反復回数**: `n_iter_`属性から収束までの反復数
- **係数のスパース性**: 非ゼロ係数の割合（verbose > 1）

### **4. 利用可能なログレベル**

| verbose値 | 出力内容 |
|-----------|----------|
| 0 | 基本情報のみ |
| 1 | + データ統計、訓練時間、収束情報 |
| 2+ | + モデル係数のスパース性情報 |

### **5. その他のログ出力方法**

**A. scikit-learnの警告を有効化**
```python
import warnings
warnings.filterwarnings('default')  # 収束警告などを表示
```

**B. 進捗バーの追加**
```python
from tqdm import tqdm
# カスタム進捗表示の実装
```

**C. ログレベルの調整**
```yaml
# configs/lightweight.yaml
logging:
  level: "DEBUG"  # より詳細なログ
```

この実装により、ロジスティック回帰の訓練プロセスを詳細に監視できるようになります。

```python
def fit(self, X: np.ndarray, y: np.ndarray, verbose: int = 1):
    self.logger.info("Starting LogisticRegression training...")
    self.logger.info(f"Training data shape: {X.shape}")
    self.logger.info(f"Number of classes: {len(np.unique(y))}")
```

```python
import warnings
warnings.filterwarnings('default')  # 収束警告などを表示
```

```python
from tqdm import tqdm
# カスタム進捗表示の実装
```

```yaml
# configs/lightweight.yaml
logging:
  level: "DEBUG"  # より詳細なログ
```

新しいエラーが発生しています。`np.bincount(y)`でエラーが出ているのは、`y`（ラベル）が文字列（'Perl'など）のままで、数値にエンコードされていないためです。

